# -*- coding: utf-8 -*-
"""
@author: yaron

The function create_data_set(geom_list, data_list, parDict) creates the data
needed for the DFTB model. 

geom_list is a list of Geometry objects
data_list is a list of strings specifying data to be returned
parDict   is the parDict object used by the DFTB class

The allowed data for data_list is:

***** 'models' *****
List of all models required to describe the molecules in geom_list

The Hamiltonian matrix elements of DFTB are derived from the functions in the 
SKF files. We refer to each type of data (a constant number or a  column of 1
the SKF file giving the value as function of bond lenght) as a Model.
  Model = namedtuple('Model',['oper', 'Zs', 'orb'])
     'oper' -- string specifying operator type, e.g. 'H', 'S', 'G'
     'Zs'   -- tuple (Z,) or (Z1,Z2) specifying atom types for on-atom or
               between atom blocks, respectively
     'orb'  -- orbital type, e.g. s,p,d for on atom,  
               ss, sp, pp_sigma, pp_pi.. off diagonal

**** 'mod_raw' *****
Dict mapping Model --> List of RawData associated with that model

Each time DFTB generates a value from data in the SKF files, Batch stores this in a
list of RawData
  RawData = namedtuple('RawData',['index','glabel','Zs','atoms','oper',
                                  'orb','dftb','rdist'])
     'index' -- integer generated by Batch as a unique ID to this value
     'glabel'-- integer specifying the location of this geometry in geom_list
     'atoms' -- tuple of (atom,) or (atom1,atom2) specifying the atom numbers
                in the geometry to which this matrix element applies
     'oper','Zs','orb' -- specify the Model (see above)
     'dftb'  -- the value generated from the DFTB skf files of ParDict
     'rdist' -- distance between atoms (added for convenience, could
                be removed at some point since accessible from glabel and 
                geom_list)



Internally, create_data_set uses a Batch object to gather the data.
Batch is passed to the DFTB class to gather information on the 
Hamiltonian matrix elements, as they are being constructed in DFTB. This is 
done through callbacks that pass Batch the needed information. 


               
                
The job of the ML model is to do a better job of predicting the values stored
in RawData. DFTB predicts the matrix element using only:
   DFTB   'oper', 'Zs', 'orbs', 'rdist' --> value
'glabel' and 'atoms' can be used to determine the environment of the atom or
atoms involved in the matrix element, such that a potentially better prediction
can be made.

DFTB does a linear transformation from the values generated from the SKF files 
to the operators themselves. These linear transformations are stored in:
  RotData = namedtuple('RotData',['raw_indices','rot_indices','rot'] )
      'rot'= NxM matrix for the transformation 
              rotated_matrix_elements = rot * raw_matrix_elements
     'raw_indices' = M integers that are the RawData 'index' values for the
                     raw_matrix elements
     'rot_indices' = N integers generated by Batch, as unique IDs for the
                     rotated_matrix_elements. The convention is that a
                     rot_index of 0 indicates a value of 0, and a rot_index
                     of 1 indicates a value of 1. 

The final set of information is in Batch.mol_oper, which is a dictionary
   mol_oper[(glabel,oper)] = matrix of integers such that
   
   mol_oper[(glabel, oper)][i,j] = integer holding the value of 
        RotData's rot_indices corresponding to the [i,j]'s element of this
        operator (glabel is the geometry ID and 'oper' is as above)
   
   This allows the matrix for an operator of type 'oper' for geometry with 
   label 'glabel' to be obtained as
         OperMatrix = rotated_matrix_elements[mol_oper[ (glabel,oper) ]] 
   where rotated_matrix_elements is a list ordered along rot_indices.
   
   The convention that rot_index of 0 indicates 0 and rot_index of 1 indicates 1
   allows a single gather operation to assemble the operator matrices into
   a single tensor.
   
Notes:
  matelem.py: _HDiag constrains energy of the p orbitals on a given atom
  to have the same value. This could be generalized, but would need to also
  ensure features could handle this
  
  

"""
import numpy as np
import scipy.linalg

from collections import OrderedDict, Counter
from itertools import chain
from functools import partial

from Geometry import to_cart
from DFTBpy import DFTB
from Auorg_1_1 import ParDict 
from .util import list_contains

from MasterConstants import RawData, RotData, Model, ANGSTROM2BOHR

try:
    import matplotlib.pylab as plt
except:
    pass

import logging

logger = logging.getLogger(__name__)


#def get_offdiag_models_for_Zs(oper,Zs):
#    '''
#    input:
#      oper : 'H', 'G', or 'R'
#      Zs   : List of element types
#    output:
#      all relevant models for these elements    
#      allowed orbs are ['ss','sp','pp_sigma','pp_pi,''sd','pd_sigma','pd_pi',
#           'dd_sigma','dd_pi','dd_delta']
#    '''
##%% 
#Zs = [1,6,7,79]
#Zpairs = [(Z1,Z2) for Z1 in Zs for Z2 in Zs if Z1 > Z2]
#shells = {}
#orient = {'ss': [], 'sp': [] , pp': ['_sigma','_pi'], 'pd':['_sigma','_pi'], 
#          'dd': ['_sigma','_pi','_delta']}
#for Z in Zs:
#    shells[Z] = ['s']
#    if Z > 1:
#        shells[Z].append('p')
#    if Z > 18:
#        shells[Z].append('d')
##%%        
#    for (Z1,Z2) in Zpairs:
#        
#            
#    if oper == 'R':
#        orbs = ['ss']
#    elif oper == 'G':
#        if max(Zs) > 1:
#            orbs.extend(['sp'])
#        if max(Zs) > 18:
#            orbs.extend(['sd'])
#        if max(Zs) > 1 and min(Zs) > 1:
#            orbs.extend(['pp'])
#        if max(Zs) > 18 and min(Zs) > 1:
#            orbs.extend(['pd_sigma','pd_pi'])
#        if max(Zs) > 18 and min(Zs) > 18:
#            orbs.extend(['dd_sigma','dd_pi','dd_delta'])
#    else:
#        orbs = ['ss']
#        if max(Zs) > 1:
#            orbs.extend(['sp'])
#        if max(Zs) > 18:
#            orbs.extend(['sd'])
#        if max(Zs) > 1 and min(Zs) > 1:
#            orbs.extend(['pp_sigma','pp_pi'])
#        if max(Zs) > 18 and min(Zs) > 1:
#            orbs.extend(['pd_sigma','pd_pi'])
#        if max(Zs) > 18 and min(Zs) > 18:
#            orbs.extend(['dd_sigma','dd_pi','dd_delta'])
#    return orbs

def to_model(raw):
    return Model(raw.oper,raw.Zs,raw.orb)

def get_model_str(mod):
    Zstr = str(mod.Zs[0])
    if len(mod.Zs) == 2:
        Zstr += '_'+str(mod.Zs[1])
    return 'Mod' + mod.oper+Zstr+mod.orb

#def convert_data_to_accelerated(bdata):
#    if bdata.has_key('dQ'):
#        curr = bdata['dQ']
#        bdata['dQ'] = {k: -0.5 * v for k,v in curr.iteritems()}
#    if bdata.has_key('dQinit'):
#        curr = bdata['dQinit']
#        bdata['dQinit'] = {k: -0.5 * v for k,v in curr.iteritems()}
#    if bdata.has_key('qneutral'):
#        curr = bdata['qneutral']
#        bdata['qneutral'] = {k: 0.5 * v for k,v in curr.iteritems()}
#    if bdata.has_key('rho'):
#        curr = bdata['rho']
#        bdata['rho'] = {k: 0.5*v for k,v in curr.iteritems()}
#    return bdata

class Batch(object): 
    def __init__(self, par_dict, opers_to_model = ['H','S','G','R'], 
                 unique_gtypes = None, *args, **kwargs):
        self.raw_data = [] 
        self.rot_data = []
        self.mol_oper = {}
        self.par_dict = par_dict
        self.opers_to_model = opers_to_model
        # dictionaries self.dftb[glabel] and self.geom
        #  SCF has not yet been called on the dftb objects
        self.dftb = {}
        self.geom = {}
        # molecule type, to be used for Eref based on molecule type
        # the passed in unique_gtypes is for training on molecules with same
        # emp formula, but different identities. In such cases, the graph cares
        # only about emp_formula, but the reference energy cares about 
        # molecule type, and all molecules types may not be in this minibatch.
        # So need a full list of all possible names, even those not present
        # here. 
        self.gtype = {}
        self.unique_gtypes = unique_gtypes
        
        self.current_oper = None
        self.current_glabel = None
        self.current_atoms = None
        self.current_Zs = None
        self.raw_counter = 0
        self.rot_counter = 2 # convention is that rot index of 0 means value=0
                             # and rot_index of 1 means value=1
        # rep_geom[glabel] = raw indices for repulsions in geom with glabel
        self.rep_geom = {}
        
        # cached results, based on profiling
        self.transformations = None
        self.mod_raw = None

        self.BYPASS_UHF_SAFETY_CHECK = kwargs.get('BYPASS_UHF_SAFETY_CHECK', False)
        
        self.fixed_Zs =  kwargs.get('FIXED_ZS', None)
        if self.fixed_Zs is not None:
            self.fixed_Zs = np.sort(self.fixed_Zs)

    def set_oper(self, oper):
        self.current_oper = oper
        
    def set_glabel(self, glabel):
        if glabel is not None:
            #print 'glabel set to ',glabel
            self.current_glabel = glabel
        else:
            raise Exception('set_glabel called with None')
            
    def set_atoms(self, atoms):
        #print 'atoms set to ', atoms
        self.current_atoms = atoms

    def set_Zs(self, Zs):
        self.current_Zs = Zs

    def add_raw(self, orb, dftb, rdist_bohr=0.0, flip_atoms = False):
        # matelem.py treats, e.g., sp and ps differently by doing
        #  par =  self.__parDict[atom1.elem + '-' + atom2.elem]
        #  par21 = self.__parDict[atom2.elem + '-' + atom1.elem]
        #  spBlk = self._SpBlk(par, xyz, dist) if pOn2 else sDum
        #  psBlk = self._SpBlk(par21, -xyz, dist,True).T if pOn1 else sDum.T
        # since  set_Zs and set_atoms was called before this, if
        # flip_atoms is true, need to reverse those. Note that 
        # since xyz --> -xyz above, the rotation matrices etc are
        # still set based on vector pointing from atom0 to atom1

        if self.current_oper not in self.opers_to_model:
            return -1

        if flip_atoms:
            atoms = [self.current_atoms[1], self.current_atoms[0]]
            Zs    = [self.current_Zs[1], self.current_Zs[0]]
        else:
            atoms = [x for x in self.current_atoms]
            Zs    = [x for x in self.current_Zs]
        
        # want to make sure that we dont create two models describing the
        # same quantity:
        #   ss, pp_sigma, pp_pi    Z0,Z1 = Z1,Z0
        #   sp                     
        # TODO: Check that this is all still fine with d orbitals included
        if orb in ['ss','pp_sigma','pp_pi','dd_sigma','dd_pi','dd_delta'] \
              and self.current_oper not in ['G','R']:
            if len(Zs) != 2:
                print('Zs is messed up')
            if Zs[0] < Zs[1]:
                atoms[0],atoms[1] = atoms[1],atoms[0]
                Zs[0],Zs[1]       = Zs[1],Zs[0]

        
        if isinstance(dftb, np.ndarray):
            if len(dftb.shape) == 0:
                dftb = dftb.tolist()
            elif len(dftb.shape) == 1:
                dftb = dftb[0]
            else:
                dftb = dftb[0][0]
        self.raw_counter += 1
        self.raw_data.append(RawData(self.raw_counter,
                                     self.current_glabel, 
                                     tuple(Zs), 
                                     tuple(atoms), 
                                     self.current_oper, 
                                     orb, 
                                     dftb,
                                     rdist_bohr / ANGSTROM2BOHR) )
        return self.raw_counter

    def add_rot(self, raw_indices, rot):
        if self.current_oper not in self.opers_to_model:
            # return array of correct size, but use negative indices 
            # so error will be thrown if these are used
            return list(range(-100, -100 + rot.shape[0]))
        if rot is None:
            rot_range = list(range(self.rot_counter, 
                              self.rot_counter+len(raw_indices)))
            self.rot_data.append(RotData(raw_indices, rot_range, np.array([1])))
            self.rot_counter += len(raw_indices)
        else:
            rot_range = list(range(self.rot_counter, 
                              self.rot_counter+rot.shape[0]))
            self.rot_data.append(RotData(raw_indices, rot_range, rot))
            self.rot_counter += rot.shape[0]
        return rot_range
        
    def set_mol_oper(self, index_matrix ):
        if self.current_oper not in self.opers_to_model:
            return
        val = index_matrix.astype(np.int_)
        if self.current_oper == 'S':
            np.fill_diagonal(val, 1)
        self.mol_oper[(self.current_glabel,self.current_oper)] = val

    def add_raw_rep(self, glabel, Zs, atoms, dftb, rdist_bohr):
        if 'R' not in self.opers_to_model:
            return 0
        if Zs[0]<Zs[1]:
            atoms = [atoms[1], atoms[0]]
            Zs    = [   Zs[1],    Zs[0]]
        
        self.raw_counter += 1
        self.raw_data.append(RawData(self.raw_counter,
                                     glabel, 
                                     tuple(Zs), 
                                     tuple(atoms), 
                                     'R', 
                                     'ss', 
                                     dftb,
                                     rdist_bohr / ANGSTROM2BOHR) )
        return self.raw_counter

    def set_rep_oper(self, glabel, index_matrix ):
        if 'R' not in self.opers_to_model:
            return
        val = index_matrix.astype(np.int_)
        self.rep_geom[glabel] = val

    def add_geometry(self, glabel, geom, gtype = None, charge=0, mult=1, 
                     verbose=False, smearing = None):
        self.dftb[glabel] = DFTB(self.par_dict, to_cart(geom), charge=charge, 
                  mult=mult, verbose=verbose, batch=self, glabel = glabel,
                  smearing = smearing)
        if (glabel in list(self.geom.keys())):
            raise ValueError('Batch.add_geometry  glabel already exists')
        self.geom[glabel] = geom
        self.gtype[glabel] = gtype

    def get_geom(self, glabel):
        return self.geom[glabel]
        
    def get_geoms_by_glabel(self):
        return self.geom

    def get_dftb(self, glabel):
        '''
            dftb object for glabel. 
            batch does not call .SCF() on this object 
        '''
        return self.dftb[glabel]
                           
    def get_dftbs(self):
        res =  OrderedDict()
        for shp,glabels in self.get_glabels().items():
            res[shp] = [self.get_dftb(i) for i in glabels]
        return res
        
    def get_dftb_oper(self, glabel, oper):
        # Not really used.. is a debugging step
        Oind = self.mol_oper[(glabel,oper)]
        nbasis = Oind.shape[0]
        
        raw_indices = np.array([r.index for r in self.raw_data],np.int_)
        raw_values  = np.array([r.dftb for r in self.raw_data])
        raw = np.zeros(np.max(raw_indices)+1)
        raw[raw_indices] = raw_values
        
        rvals = np.zeros([self.rot_counter])
        
        for rot in self.rot_data:
            rvals[rot.rot_indices] = np.dot(rot.rot, raw[rot.raw_indices])
        
        res = rvals[Oind.flatten()].reshape([nbasis,nbasis])
        if oper == 'S':
            np.fill_diagonal(res, 1.0)
        return res

    def get_models(self):
        '''
        retuns list of all models in the Batch, 
        sorted by (oper, len(Zs), Zs, orb)
        '''
        models = list(set( [to_model(r) for r in self.raw_data] ))
        models.sort(key = lambda x: (x.oper, len(x.Zs), x.Zs, x.orb))
        return models
 
    def get_mod_raw(self, models = None):
        if self.mod_raw is None:
            self.mod_raw = self.calc_mod_raw(models)
        return self.mod_raw
        
    def calc_mod_raw(self, models = None):
        '''
        returns dictionary with
        mod_raw[model] = all RawData for that model,
                         sorted by (glabel, atoms)
        '''
        if models is None:
            models = self.get_models()
        mod_raw = OrderedDict()
        for m in models:
            mod_raw[m] = [r for r in self.raw_data if to_model(r) == m]
            mod_raw[m].sort(key = lambda x: (x.glabel, x.atoms))
        return mod_raw
    
    def get_basis_sizes(self):
        '''
        returns list of integers holding the unique basis set sizes
        in the batch, sorted from low to high
        '''
        basis_sizes = list(set( [x.nBasis() for x in list(self.dftb.values())] ))
        #basis_sizes = list(set( [ self.mol_oper[olabel].shape[0] for olabel 
        #                 in self.mol_oper.keys()]))
        basis_sizes.sort()
        return basis_sizes
        
    def get_onames(self):
        '''
        return list of strings, with names of operators in batch (e.g 'H1'
        'S'), sorted alphabetically
        '''
        onames = list(set( [ olabel[1] for olabel in list(self.mol_oper.keys())]))
        onames.sort()
        return onames

    def get_glabels(self, basis_sizes = None):
        '''
        returns dictionary such that
          glabels[bsize] = list of glabels of that basis size 
        This list is sorted by glabel 
        '''
        if basis_sizes is None:
            basis_sizes = self.get_basis_sizes()
        
        res = {bsize:[] for bsize in basis_sizes}
        for glabel, dftb in self.dftb.items():
            res[dftb.nBasis()].append(glabel)
        for shp,labels in res.items():
            res[shp].sort()
            
        #for bsize in basis_sizes:
        #    # will look through operators to find those with a given size
        #    #   self.mol_oper.keys() is of form: [(11, 'H'), (26, 'H'), ...]
        #    # H,S, and G are of same size. Select the first one so we only
        #    #   count each geometry once
        #    oper0 = self.get_onames()[0]
        #    res[bsize] = [olabel[0] for olabel in self.mol_oper.keys()  \
        #                           if (self.mol_oper[olabel].shape[0] == bsize
        #                           and olabel[1] == oper0)]
        #    res[bsize].sort() 
        return res
                
    def get_qneutral(self):
        # returns charge in each atomic orbital, for atoms to be neutral as
        # dictionary with keys of basis size, bsize:
        #        qneutral[bsize] = np array of size [ngeom, bsize,1]
        # where the ngeometries are ordered by glabel
        # used to calculate the change in charge, dQ, of DFTB
        qN = {}
        glabels_all = self.get_glabels()
        for bsize, glabels in glabels_all.items():
            qtemp = np.zeros([len(glabels), bsize,1])
            for ilabel,glabel in enumerate(glabels):
                dftb = self.get_dftb(glabel)
                qnShell = np.array(dftb.GetShellQNeutral())
                sbasis  = dftb.GetShellBasis()
                zipList = list(zip(qnShell, sbasis))
                qtemp[ilabel,:,0] = sum(   \
                   [[qneut/len(bas)] * len(bas) for qneut, bas in zipList], [])           
            qN[bsize] = qtemp
        return qN

        
    # REMOVED because occ_rho_mask is now assumed to depend on SCF solution
    #def get_occ_rho_mask(self):
    #    # used to compute density matrix from orbitals
    #    # returns array such that orb * mask zero's out unoccupied orbitals
    #    #   occ_mask[bsize] = np array of size [ngeom, bsize]
    #    occ_mask = {}
    #    # get list of ordered geometries using H1 operator
    #    # gdata[bsize] = list of (glabel, 'H1') with basis size of bsize
    #    glabels_all = self.get_glabels()
    #    for bsize, glabels in glabels_all.iteritems():
    #        otemp = np.zeros([len(glabels), bsize,bsize])
    #        for ilabel,glabel in enumerate(glabels):
    #            dftb = self.get_dftb(glabel)
    #            ne = dftb.GetNumElecAB()[1]
    #            otemp[ilabel,:,:ne] = 1.0            
    #        occ_mask[bsize] = otemp
    #    return occ_mask

    def get_occ_eorb_mask(self):
        # used to compute sum of filled orbitals
        # returns array with 2 for for filled orbitals 0 without 
        #   occ_mask[bsize] = np array of size [ngeom, bsize]
        occ_mask = {}
        glabels_all = self.get_glabels()
        for bsize, glabels in glabels_all.items():
            otemp = np.zeros([len(glabels), bsize])
            for ilabel,glabel in enumerate(glabels):
                dftb = self.get_dftb(glabel)
                ne = dftb.GetNumElecAB()[1]
                if type(ne) != int and self.BYPASS_UHF_SAFETY_CHECK:
                    # If we are bypassing the UHF safety checks in dftb.py
                    # then it is possible that us fetching ne in this manner
                    # may result in a fractional value being returned to us.
                    # so round it up.
                    ne = int(np.ceil(ne))
                otemp[ilabel,:ne] = 2.0            
            occ_mask[bsize] = otemp
        return occ_mask

    def get_homo_number(self):
        # number of the highest occupied molecular orbital
        #   orb_num[bsize] = np array of size [ngeom]
        orb_num = {}
        glabels_all = self.get_glabels()
        for bsize, glabels in glabels_all.items():
            otemp = np.zeros([len(glabels)],dtype = np.int32)
            for ilabel,glabel in enumerate(glabels):
                dftb = self.get_dftb(glabel)
                ne = dftb.GetNumElecAB()[1]
                otemp[ilabel] = int(ne-1)  
            orb_num[bsize] = otemp
        return orb_num
 
    def get_Zs(self):
        # ordered list of all elements in the dataset
        if self.fixed_Zs is not None:
            return self.fixed_Zs

        glabels_all = self.get_glabels()
        all_Zs = []
        for bsize, glabels in glabels_all.items():
            for ilabel,glabel in enumerate(glabels):
                all_Zs.extend( self.get_geom(glabel).z )
        Zs = np.sort(np.unique(all_Zs)).tolist()
        
        return Zs

    def get_zcounts(self):
        # number of each type of element in the data set
        # returns res[bsize][igeom, #element]

        Zs = self.get_Zs()
        Z_to_i = {Z:i for i,Z in enumerate(Zs)}

        res = {}
        glabels_all = self.get_glabels()
        for bsize, glabels in glabels_all.items():
            temp = np.zeros([len(glabels),len(Zs)])
            for ilabel,glabel in enumerate(glabels):
                zdict = Counter( self.get_geom(glabel).z )
                for z,nz in zdict.items():
                    temp[ ilabel, Z_to_i[z]] = nz
            res[bsize] = temp
        return res

    def get_unique_gtypes(self):
         # ordered list of all gtypes in the dataset
        if self.unique_gtypes is None:
            all_gtypes = []        
            glabels_all = self.get_glabels()
            for bsize, glabels in glabels_all.items():
                all_gtypes.extend([self.gtype[x] for x in glabels])
            self.unique_gtypes = np.sort(np.unique(all_gtypes)).tolist()
        return self.unique_gtypes

    def get_gtype_indices(self):
        '''
        returns res[shp][i] = itype   where  get_unique_gtypes()[itype] = glabel
        so that Eref can be  gather(gtype_variable, gtype_indices)
        where gtype_variables are the reference energies for eacth gtype, ordered
        as in get_unique_gtypes
        '''
        unique_gtypes = self.get_unique_gtypes()
        gtype_to_i = {gtype:i for i,gtype in enumerate(unique_gtypes)}

        res = {}
        glabels_all = self.get_glabels()
        for bsize, glabels in glabels_all.items():
            gtypes = [self.gtype[x] for x in glabels]
            res[bsize] = np.array([gtype_to_i[x] for x in gtypes],dtype=np.int_)
        return res
        
    # TODO: Moved to DFTBList. Delete from here once tested.
    #def get_dQ(self):
    #    # returns DFTB delta-q for each atomic orbital
    #    # dictionary with keys of basis size, bsize:
    #    #        dQ[bsize] = np array of size [ngeom, bsize,1]
    #    # where the ngeometries are ordered by glabel
    #    qN = self.get_qneutral()
    #    dQ = {}
    #    glabels_all = self.get_glabels()
    #    for bsize, glabels in glabels_all.iteritems():
    #        qtemp = np.zeros([len(glabels), bsize,1])
    #        for ilabel,glabel in enumerate(glabels):
    #            dftb = self.get_dftb(glabel)
    #            E,Flist,rholist = dftb.SCF()
    #            S  = dftb.GetOverlap()
    #            rho = 2.0 * rholist[0]
    #            qBasis = (rho)*S
    #            GOP = np.sum(qBasis,axis=1)
    #           qtemp[ilabel,:,0] = qN[bsize][ilabel,:,0] - GOP    
    #       dQ[bsize] = qtemp
    #    return dQ

    def get_dipole_mat(self):
        # returns matrix needed to get dipole moment from orbital charges
        #   res = dictionary with key of basis_size=nbasis and value
        #   res[nbasis] = mu such that
        # u(igeom,x,1) = sum_ibasis mu(igeom,x,ibasis) * q(igeom,ibasis,0)
        #   ngeom,3,1                   ngeom,3,nbasis   ngeom,nbasis,1
        # which in tensorflow will just be:
        # tfdata['dipole'][shp] = tf.matmul(tfdata['dipole_mat'][shp] ,
        #                                   tfdata['dQ'][shp]
        res = OrderedDict()
        glabels_all = self.get_glabels()
        for bsize, glabels in glabels_all.items():            
            dipole = np.zeros([len(glabels), 3, bsize],dtype=np.float64)
            for ilabel,glabel in enumerate(glabels):
                dftb = self.get_dftb(glabel)
                geom = self.get_geom(glabel)
                onatom = np.array(dftb.GetOnAtom(), dtype = np.int64)
                dipole[ilabel,:,:] = geom.rcart[:,onatom]
            # convert from amu Angstrom to debye (http://cccbdb.nist.gov/debye.asp)
            res[bsize] = dipole / 0.208194
        return res

    ### DO NOT USE WITHOUT TESTING

    def one_center_dipole():
        """
        This formula came from Tanya's notes

        Assuming n = 2 since we are doing organics
        """
        n = 2
        s, p = 1, 1 #Replace with correct parameter values!
        first_term = ((2 * n) + 1) * (2**((2*n) + 1)) * ((s * p)**(n + 0.5))
        second_term = (3**0.5) * ((s + p)**((2*n) + 2))
        return first_term / second_term
         
    def get_XYZ_mat(self):
        """
        First attempt at generating the XYZ matrices required for 
        incorporating influence of an external field
        Currently only generates the diagonal matrix of the respective
           coordinates X, Y, Z
        TODO: Generate off-diagonal elements correctly

        Notes: This function is tied to the GetOnAtom() and GetShellBasis()
            methods of the dftb object. The GetOnAtom() extracts the indices
            of the atoms. For example, for a single carbon atom, you get the following
            for shellbasis and onatom:
            
            shellbasis = [[0], [1,2,3]]
            onatom = [0, 0, 0, 0]

            Assuming only organics, the off-diagonal element locations in the 
            one-centered dipole integral can be found as the intersection of 
            the index 0 and index 1, 2, or 3 for the px, py, or pz orbitals
            (assuming 1, 2, 3 = x, y, z). 
        """
        res = OrderedDict()
        #Maps the basis size to the glabels which are the 
        #   indices of different geometries in the list of geometries
        glabels_all = self.get_glabels()
        for bsize, glabels in glabels_all.items():
            #Stacked XYZ matrices for all the molecules of the given bsize
            X = np.zeros([len(glabels), bsize, bsize], dtype = np.float64)
            Y = np.zeros([len(glabels), bsize, bsize], dtype = np.float64)
            Z = np.zeros([len(glabels), bsize, bsize], dtype = np.float64)
            for ilabel, glabel in enumerate(glabels):
                dftb = self.get_dftb(glabel)
                geom = self.get_geom(glabel)
                #GetOnAtom() and GetShellBasis() in dftb.py
                onatom = np.array(dftb.GetOnAtom(), dtype = np.int64)
                shellbasis = np.array(dftb.GetShellBasis(), dtype = np.int64)
                #Assumption that X, Y, Z are mapped to 0, 1, 2 indices 
                #   The assignment of x, y, z does matter here because 
                #   that determines the ordering of the off-diagonal elements
                #geom.rcart has shape (3, Natom)
                X[ilabel,:,:] = np.diag(geom.rcart[0, onatom])
                Y[ilabel,:,:] = np.diag(geom.rcart[1, onatom])
                Z[ilabel,:,:] = np.diag(geom.rcart[2, onatom])
                #At this point need to figure out how to add the off-diagonal element 
                #   We exploit the fact that in shell basis, the coupling of the s
                #   orbital and p orbitals can be found in O(n) time by looking for 
                #   lists of length 1 (s) that are right before lists of length 3 (px, py, pz).
                #   Then, the location in the matrix is element 0 of the length 1 list and
                #   element 0, 1, or 2 of the length 3 list (assuming 0, 1, 2 -> x, y, z)
                for j in range(len(shellbasis) - 1):
                    curr_elem = shellbasis[j]
                    next_elem = shellbasis[j + 1]
                    #s orbital next to p orbital
                    if (len(curr_elem) == 1) and (len(next_elem) == 3):
                        #X coordinate matrix
                        s_ind = curr_elem[0]
                        X[ilabel, s_ind, next_elem[0]] = one_center_dipole()
                        X[ilabel, s_ind, next_elem[0]] = one_center_dipole() #Symmetric about the diagonal
                        #Y coordinate matrix
                        Y[ilabel, s_ind, next_elem[1]] = one_center_dipole()
                        Y[ilabel, s_ind, next_elem[1]] = one_center_dipole()
                        #Z coordinate matrix
                        Z[ilabel, s_ind, next_elem[2]] = one_center_dipole()
                        Z[ilabel, s_ind, next_elem[2]] = one_center_dipole()
            res[bsize] = np.array([X, Y, Z]) #(3, n_glabel, bsize, bsize) tensor
        return res      
    ###        

    def get_atom_ids(self):
        # atom on which the orbital resides, returns dict
        #    res[bsize] = np int64 array of size [ngeom, bsize,1]
        # atoms are numbered sequentially  within a bsize
        #
        # Used to sum dQ over all orbitals in each atom
        # DFTB.GetOnAtom() returns a list of int with atom on which each 
        #    orbital resides. 
        # tf.segment_sum(data, segment_ids)
        #    segment_ids is an ordered list, e.g. 0 0 1 1 1 2 2
        #    returns res[0] = data[0] + data[1]
        #            res[1] = data[2] + data[3] + data[4]
        # we need to create an ordered list of all atoms in the batch
        #    flatten each dQ[bsize] and concat together
        #    create the segment_ids for this
        
        res = OrderedDict()
        glabels_all = self.get_glabels()
        for bsize, glabels in glabels_all.items():            
            atom_ids = np.zeros([len(glabels), bsize,1],dtype=np.int64)
            displace = 0
            for ilabel,glabel in enumerate(glabels):
                dftb = self.get_dftb(glabel)
                onatom = np.array(dftb.GetOnAtom(), dtype = np.int64)
                atom_ids[ilabel,:,0] = onatom + displace
                displace += dftb.nAtom() 
            res[bsize]= atom_ids
        return res

    def get_azi_ids(self):
        """
        Functions identically to get_atom_ids but rather than resolving by
        atom, this will resolve by atom and azimuthal number.
        """
        # atom on which the orbital resides, returns dict
        #    res[bsize] = np int64 array of size [ngeom, bsize,1]
        # atoms are numbered sequentially  within a bsize
        #
        # Used to sum dQ over all orbitals in each atom
        # DFTB.GetOnAtom() returns a list of int with atom on which each
        #    orbital resides.
        # tf.segment_sum(data, segment_ids)
        #    segment_ids is an ordered list, e.g. 0 0 1 1 1 2 2
        #    returns res[0] = data[0] + data[1]
        #            res[1] = data[2] + data[3] + data[4]
        # we need to create an ordered list of all atoms in the batch
        #    flatten each dQ[bsize] and concat together
        #    create the segment_ids for this

        azi_ids = OrderedDict()
        glabels_all = self.get_glabels()
        for bsize, glabels in glabels_all.items():
            atom_ids = np.zeros([len(glabels), bsize, 1], dtype=np.int64)
            displace = 0
            for ilabel, glabel in enumerate(glabels):
                orbital_ids = np.array(self.get_dftb(glabel).orbital_ids)[:, [0, 2]]
                azi = np.zeros(orbital_ids.shape[0])
                for n, u in enumerate(np.unique(orbital_ids, axis=0)):
                    azi[np.where(np.all(orbital_ids == u, axis=1))[0]] = n
                atom_ids[ilabel, :, 0] = azi + displace
                displace += (n + 1)
            azi_ids[bsize] = atom_ids
        return azi_ids

    def get_norbs_atom(self):
        res = OrderedDict()
        atom_ids = self.get_atom_ids()
        for shp,ids in atom_ids.items():
            temp = Counter( ids.flatten() )
            maxid = max(temp)+1
            res[shp] = np.array([temp[i] for i in range(maxid)], np.float64)
        return res
        
    def get_orbital_ids(self):
        # TODO: Not yet tested
        #orb_ids[shp] = ngeom by 4 array holding:
        # 0 = atom index, 1 = Z, 2 = l quantum number, 3 = m quantum number
        res = OrderedDict()
        glabels_all = self.get_glabels()
        for bsize, glabels in glabels_all.items():            
            orb_ids = np.zeros([len(glabels), bsize,1],dtype=np.int64)
            for ilabel,glabel in enumerate(glabels):
                dftb = self.get_dftb(glabel)
                atom_list = dftb.get_atom_list()
                orb_ids[ilabel,:] = dftb.get_orbital_ids(atom_list)
            res[bsize]= orb_ids
        return res
        
    def get_transformations(self):
        if self.transformations is None:
            self.transformations = self.calc_transformations()
        return self.transformations
    def copy_transformations(self, source_batch):
        self.transformations = source_batch.get_transformations()
    def clear_transformations(self):
        self.transformations = None
    def calc_transformations(self):
        '''
        returns rot_map, gather_for_oper
        
        
        rot_map is an ordered dictionary where
          rot_map[shape]['gather_for_rot'] = list of integers
          rot_map[shape]['tensor'] = numpy array with 3 dimensions
                                     N, shape[0], shape[1]
                                     (or None if a linear transformation is
                                      not needed)
          shape = tuple holding shape of the linearl transformation matrices
          
        
        Linear transformation from values produced from the SKF files
        to the values needed for the operators (i.e. the slater koster
        transformations) The transfomration is done for each shape
        individualy, so that tensorflow.batch_matmul or equivalent may be
        used.
        
        For each shape s:
          tensor = rot_map[s]['tensor']
          gather = rot_map[s]['gather_for_rot']
        1) The model predictions are concatenated into raw_elements, a single 
           vector with the order being that from get_models and get_mod_raw
        2) Gather values from raw_elements:       
           gathered = raw_elements[gather].reshape([-1,s[1],1])
              the -1 will lead to array of shape N,s[1],1
        3) if tensor is not None, then do a batch multiply for the rotation
           for all i (or all at once with batch_matmul)
              rotated_elements[i,s[0],1] =  dot(tensor[i,:,:], gathered[i,:,:])
              rotated_vector = rotated_elements.reshape([-1])
           if tensor is None, rotated_vector = gathered
        The results from all shapes are then concatenated into a single vector
        with the order being the same as in the OrderedDict. 
           all_rotated = concatenated rotated_vector
        
        gather_for_oper is a dictionary with:
          gather_for_oper[oname][bsize] = numpy integer array such that
          
          all_rotated[gather_for_oper].reshape([-1,bsize,bsize]) = 
             operator matrices, with the first index ordered as in 
             opers[oname,bsize]
                
        
        '''
        # concatenated list of values from the models
        mod_raw = self.get_mod_raw()
        net_raw = []
        for m in self.get_models():
            net_raw.extend(mod_raw[m])
        # net_lookup[raw.index] = index in net_raw
        net_lookup = {r.index:index for index,r in enumerate(net_raw)}
        
        shapes = list(set( [r.rot.shape for r in self.rot_data] ))
        shapes.sort()
        # Then create rot_tensor and the list of indices
        rot_gathers = OrderedDict()
        rot_indices = [0,1]
        for s in shapes:
            rots = [r for r in self.rot_data if r.rot.shape == s]
            temp1 = [rot.raw_indices for rot in rots]
            temp2 = list(chain.from_iterable(temp1))
            gather_for_rot = np.array([net_lookup[i] for i in temp2],np.int_)
            
            temp1 = [rot.rot_indices for rot in rots]
            rot_indices.extend(list(chain.from_iterable(temp1)))
                
            rot_gathers[s] =  gather_for_rot

        onames = self.get_onames()
        basis_sizes = self.get_basis_sizes()
        labels = self.get_glabels()
        gather_for_oper = {}
        for oname in onames:
            gather_for_oper[oname] = {}
            for bsize in basis_sizes:
                gtemp = []
                for glabel in labels[bsize]:
                    oind = self.mol_oper[(glabel,oname)].ravel()
                    look_up = {i:n for n, i in enumerate(rot_indices)}
                    oind2 = [look_up[i] for i in oind]
                    gtemp.extend(oind2)
                gather_for_oper[oname][bsize] = np.array(gtemp,np.int_)


        # For repulsion, we want to use tf.segment_sum to sum over all
        # interactions in each molecule. The index in segment_sum must
        # be ordered sequentially. 
        gather_for_rep = {}
        segsum_for_rep = {}
        if 'R' in self.opers_to_model:
            for bsize,glabels in labels.items():
                gather = []
                indices = []
                for igeom, glabel in enumerate(glabels):
                    # indices stored in RawData for repults in this geometry
                    rawdata_indices = self.rep_geom[glabel]
                    netraw_indices = [net_lookup[x] for x in rawdata_indices]
                    # gather these and set indices so segment_sum will sum these
                    # into the correct position
                    gather.extend( netraw_indices )
                    indices.extend([igeom] * len(netraw_indices))
                gather_for_rep[bsize] = np.array(gather,  np.int_)
                segsum_for_rep[bsize] = np.array(indices, np.int_)

        return rot_gathers, gather_for_oper, gather_for_rep, \
               segsum_for_rep
               
    def get_rot_tensors(self):
        shapes = list(set( [r.rot.shape for r in self.rot_data] ))
        shapes.sort()
        # Then create rot_tensor
        rot_tensors = OrderedDict()
        for s in shapes:
            rots = [r for r in self.rot_data if r.rot.shape == s]
            
            if sum(s) == 1:
                rot_tensor = None
            else:
                rot_tensor = np.vstack([np.expand_dims(r.rot,0) for r in rots])        

            rot_tensors[s] =  rot_tensor
            
        return rot_tensors

class DFTBList:
    def __init__(self, batch):
        self.batch = batch
        labels = batch.get_glabels()
        self.dftbs_by_bsize = {}
        for bsize,glabels in labels.items():
            self.dftbs_by_bsize[bsize] = []
            for igeom, glabel in enumerate(glabels):
                self.dftbs_by_bsize[bsize].append( batch.get_dftb(glabel) )
        self.SCF_performed = False
        self.phiS = None
        self.Sevals = None
        self.Erep = None
        self.dQ = None
    data_fields = ['S','phiS','Sevals','H','G','F','Eelec','Erep','Etot',
                   'occ_rho_mask','rho','eorb','dQ','dQinit','dQcurr', 'entropy',
                   'fermi_energy']

    def get_dftbs_by_bsize(self):
        return self.dftbs_by_bsize
    def get_data(self,data_type):
        if data_type in ['S','H','G']:
            res = {}
            for bsize, dftbs in self.dftbs_by_bsize.items():
                res[bsize] = np.zeros([len(dftbs), bsize,bsize])
                for igeom, dftb in enumerate(dftbs):
                    if data_type == 'S':
                        res[bsize][igeom,:,:] = dftb.GetOverlap()
                    if data_type == 'H':
                        res[bsize][igeom,:,:] = dftb.GetCoreH()
                    if data_type == 'G':
                        GShell = dftb.GetGamma()
                        res[bsize][igeom,:,:] = dftb.ShellToFullBasis(GShell)
        elif data_type == 'Erep':
             res = self.get_Erep()
        elif data_type in ['phiS','Sevals']:
            phiS,Sevals = self.get_phiS_Sevals()
            if data_type == 'phiS':
                res = phiS
            elif data_type == 'Sevals':
                res = Sevals
        elif data_type in ['F','Eelec','rho','eorb','occ_rho_mask', 'entropy', 'fermi_energy']:
            self.do_SCF()
            if data_type == 'F':
                res = self.focks
            if data_type == 'Eelec':
                res = self.energies
            if data_type == 'entropy':
                res = self.entropies
            if data_type == 'rho':
                res = self.rhos
            if data_type == 'eorb':
                res = self.eorbs
            if data_type == 'occ_rho_mask':
                res = self.occ_rho_masks
            if data_type == 'fermi_energy':
                res = self.fermi_energies
        elif data_type == 'Etot':
            Erep = self.get_Erep()
            self.do_SCF()
            res = {}
            for shp,val in self.energies.items():
                res[shp] = val +Erep[shp]
        elif data_type in ['dQ','dQinit','dQcurr']:
            return self.get_dQ()
        else:
            raise ValueError(data_type + ' not supported by DFTBList.get_data')
        return res

    def get_phiS_Sevals(self):
        if self.phiS is None or self.Sevals is None:
            self.phiS = {}
            self.Sevals = {}
            for bsize, dftbs in self.dftbs_by_bsize.items():
                ngeom = len(dftbs)
                self.phiS[bsize]    = np.zeros([ngeom,bsize,bsize])
                self.Sevals[bsize]  = np.zeros([ngeom,bsize])
                for igeom, dftb in enumerate(dftbs):
                    S1 = dftb.GetOverlap()
                    Svals, Svecs = scipy.linalg.eigh( S1 )
                    self.phiS[bsize][igeom,:,:] = \
                           np.dot(Svecs,np.diag( np.sqrt(1.0/Svals) ))
                    self.Sevals[bsize][igeom,:] = Svals
        return (self.phiS, self.Sevals)
    def get_Erep(self):
        if self.Erep is None:
            res = {}
            for bsize, dftbs in self.dftbs_by_bsize.items():
                res[bsize] = np.zeros([len(dftbs)])
                for igeom,dftb in enumerate(dftbs):
                    res[bsize][igeom] = dftb.repulsion
            self.Erep = res
        return self.Erep
    def get_dQ(self):
        # DFTB delta-q for each atomic orbital
        # dictionary with keys of basis size, bsize:
        #        dQ[bsize] = np array of size [ngeom, bsize,1]
        # where the ngeometries are ordered by glabel
        if self.dQ is None:
            self.do_SCF()
            qN = self.batch.get_qneutral()
            self.dQ = {}
            for bsize, dftbs in self.dftbs_by_bsize.items():
                qtmp = np.zeros([len(dftbs), bsize,1])
                for igeom, dftb in enumerate(dftbs):
                    S   = dftb.GetOverlap()
                    rho = self.rhos[bsize][igeom,:,:]
                    qBasis = (rho)*S
                    GOP = np.sum(qBasis,axis=1)
                    qtmp[igeom,:,0] = qN[bsize][igeom,:,0] - GOP
                self.dQ[bsize] = qtmp
        return self.dQ

    def do_SCF(self):
        if not self.SCF_performed:
            self.focks = {}
            self.energies = {}
            self.eorbs = {}
            self.rhos = {}
            self.occ_rho_masks = {}
            self.entropies = {}
            self.fermi_energies = {}
            for bsize, dftbs in self.dftbs_by_bsize.items():
                ngeom = len(dftbs)
                self.energies[bsize] = np.zeros([ngeom])
                self.entropies[bsize]= np.zeros([ngeom])
                self.fermi_energies[bsize] = np.zeros([ngeom])
                self.focks[bsize]    = np.zeros([ngeom,bsize,bsize])
                self.rhos[bsize]     = np.zeros([ngeom,bsize,bsize])
                self.occ_rho_masks[bsize] = np.zeros([ngeom,bsize,bsize])
                self.eorbs[bsize]    = np.zeros([ngeom,bsize])
                for igeom, dftb in enumerate(dftbs):
                    #try:
                    energy, fockList, densList, occ_rho_mask = dftb.SCF(get_occ_rho_mask = True)
                    #except:
                    #logger.error('DFTBList.doSCF: DFTB failed to converge')
                    #energy, fockList, densList = dftb.SCF(raise_exception = False)
                    self.energies[bsize][igeom] = energy
                    self.focks[bsize][igeom,:,:] = fockList[0]
                    self.rhos[bsize][igeom,:,:]  = 2.0*densList[0]
                    self.occ_rho_masks[bsize][igeom,:,:]  = occ_rho_mask
                    self.entropies[bsize][igeom] = dftb.entropy
                    self.fermi_energies[bsize][igeom] = dftb.fermi_level
                    self.eorbs[bsize][igeom,:] , _ = \
                         scipy.linalg.eigh(a=fockList[0],
                                           b=dftb.GetOverlap())

            self.SCF_performed = True
        

def create_batch(geom_list, opers_to_model = ['H','G','R'], gtypes = None,
                 parDict = None, unique_gtypes = None, charges = None,
                 smearings = None, *args, **kwargs):
    
    if parDict is None:
        parDict = ParDict()
    if smearings is None:
        smearings = [None]*len(geom_list)
    BYPASS_UHF_SAFETY_CHECK = kwargs.get('BYPASS_UHF_SAFETY_CHECK', False)
    FIXED_ZS = kwargs.get('FIXED_ZS', None)
    batch = Batch(parDict,opers_to_model, unique_gtypes = unique_gtypes, 
                  BYPASS_UHF_SAFETY_CHECK=BYPASS_UHF_SAFETY_CHECK,
                  FIXED_ZS=FIXED_ZS)
    glabel = 0
    if charges is None:
        charges = np.zeros(len(geom_list))
    for igeom,geom in enumerate(geom_list):
        if gtypes is None:
            batch.add_geometry(glabel,geom,charge=charges[igeom],smearing = smearings[igeom])
        else:
            batch.add_geometry(glabel,geom,gtype=gtypes[igeom],
                               charge=charges[igeom], smearing = smearings[igeom])
        glabel += 1

    return batch
    

def create_dataset(batch, dftblist, data_list):
    '''
    Creates data for the element prediction net.

    Returns:
       res[data_type]: dictionary maping data_type(string) to data
    '''
    
    # source will either hold the data, or a function that can be called, with
    # no arguments, to get the data
    source = {}
    glabels = batch.get_glabels()
    source['models'         ] = batch.get_models 
    source['onames'         ] = batch.get_onames
    source['basis_sizes'    ] = batch.get_basis_sizes
    source['geoms'          ] = batch.get_geoms_by_glabel
    source['glabels'        ] = glabels
    source['qneutral'       ] = batch.get_qneutral
    #source['occ_rho_mask'   ] = batch.get_occ_rho_mask
    source['occ_eorb_mask'  ] = batch.get_occ_eorb_mask
    source['homo_num'       ] = batch.get_homo_number
    source['mod_raw'        ] = batch.get_mod_raw
    source['dipole_mat'     ] = batch.get_dipole_mat
    source['atom_ids'       ] = batch.get_atom_ids
    source['azi_ids'] = batch.get_azi_ids
    source['norbs_atom'     ] = batch.get_norbs_atom
    source['Zs'             ] = batch.get_Zs
    source['zcounts'        ] = batch.get_zcounts   
    source['dftbs'          ] = batch.get_dftbs
    source['rot_tensors'    ] = batch.get_rot_tensors
    source['unique_gtypes'  ] = batch.get_unique_gtypes
    source['gtype_indices'  ] = batch.get_gtype_indices
    source['orbital_ids'    ] = batch.get_orbital_ids
    
    transform_types = ['gather_for_rot', 'gather_for_oper',
                       'gather_for_rep', 'segsum_for_rep'] 
    if list_contains(data_list, transform_types):
        source['gather_for_rot'], \
        source['gather_for_oper'], \
        source['gather_for_rep'], \
        source['segsum_for_rep']  = batch.get_transformations() 

    if list_contains(data_list,['dftb_elements','dftb_r']):
        # Output from the network will be ordered by model type
        # net_raw will hold the raw elements, ordered as in the net output
        net_raw = []
        models = batch.get_models()
        mod_raw = batch.get_mod_raw()
        for m in models:
            net_raw.extend(mod_raw[m])        
        # dftb values for the net output
        source['dftb_elements'] = np.array([r.dftb for r in net_raw])
        source['dftb_r']        = np.array([r.rdist for r in net_raw])        
    
    # All information that requires and SCF cycle is handled here.
    # This will checks if this is something that needs an SCF cycle,
    # (checked against known list), if so call the function.
    # -> See line 788
    if list_contains(data_list,DFTBList.data_fields):
        for data_type in DFTBList.data_fields:
            # Source will be a function here.
            source[data_type] = partial(dftblist.get_data,data_type=data_type)
    res = {}
    for data_type in data_list:
        if data_type not in source:
            raise ValueError(data_type + ' not supported by create_dataset')
        if callable(source[data_type]):
            res[data_type] = source[data_type]()
        else:
            res[data_type] = source[data_type]
        
    return res

